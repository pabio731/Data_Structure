



 재귀 호출은 기본적으로 비선형 자료구조에 기반을 둔 다양한 알고리즘에
사용된다. 예를 들어 트리 혹은 그래프의 탐색, 다원 탐색 트리에서 노드를
삭제 또는 병합 할 때 사용.

다양한 분야에서 여러가지 정의로 사용되지만 문제 해결을 위한 접근 방식으로
사용되기도 한다.

재귀적 접근 방법은 일단 큰 문제를 여러 개의 작은 문제들로 나누는 것으로부터 시작
이때 나누어진 작은 문제는 모두 같은 타입이어야 한다는 제약이 있음.

또 다른 특성으로 종료 조건이 있다.나누어진 작은 문제가 여전히 해결하기 어렵다면,
다시 더 작은 문제들로 나누다가 더의상 쪼갤 수 없을 정도로 작아졌을 때,
즉 문제 수준이 간단한 사칙연산 수준이 될 때까지 문제를 단순화 시킨다.

이렇게 여러 개의 문제들로 쪼개어 해결한다는 뜻에서 분할 정복(Divide and Conquer)의 한 방법이라고도 함.

재귀적 접근 방법을 구현하는 가장 한다한 방법은 재귀 호출이다.
자기 자신을 다시 호출하는 것.

재귀호출은 단순함과 강력함 때문에 보통 프로그램이나 문제 해결의 초기 단계에 많이 쓴다.
하지만 성능상의 몇 가지 제약 사항 때문에 문제 해결 방법이 어느 정도 고정된 다음에는
비 배귀적인 방법, 즉 반복적인 방법으로 다시 수정하기도 함.

아주 대표적인 예시로 n!의 계산을 들 수 있는데,
n!은 다시 n*(n-1)!으로 나눌 수 있다.

팩토리얼 계산에서 다시 팩토리얼 정의가 사용된 것.
이렇게 자신의 정의를 다시 사용해 문제를 해결하는 방식을 "재귀 호출"혹은 "순환 호출"이라고함.
또한 재귀 호출의 종료 조건을 "기본 경우" 또는 "최소 한계"라고 한다.
만약 최소한계를 정하는 부분이 없다면 그저 무한히 동작하게 된다.


재귀 호출과 비교되는 방법으로 반복 호출이 있다. 반복은 for나 while을 이용해
반복적으로 명령을 실행해 문제를 해결하는 방법이다.
재귀호출이 반복호출과 비교해서 가지는 장점은 알고리즘의 간결성과 명확성임.
하지만 시스템 스택을 사용하기 때문에 수행시간이 더 오래 걸리며 스텍 메모리 문제가
발생할 수 있다는 단점이 있다.

반복호출은 시스템 스택을 사용하지 않기 때문에 프로그램 속도 혹은 메모리 측면에서
재귀호출보다 성능이 우수하다. 따라서 설명에서는 재귀로 하고 실제 구현은 
반복을 이용할 때도 있다.